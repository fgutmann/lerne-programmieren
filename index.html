<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="de-at" lang="de-at">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.53" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>TicTacToe - Lerne Programmieren &middot; Lerne Programmieren</title>

  
  <link type="text/css" rel="stylesheet" href="https://fgutmann.github.io/lerne-programmieren/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://fgutmann.github.io/lerne-programmieren/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://fgutmann.github.io/lerne-programmieren/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://fgutmann.github.io/lerne-programmieren/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Lerne Programmieren" />

  <style type="text/css">
    .sidebar-about h1 {
        font-size:1.8rem;
        font-weight:400;
    }
    figure {
        margin:1rem;
    }
    figcaption h4 {
        font-size:0.8rem;
        font-weight:normal;
        font-style:italic;
        color:#999;
    }
    .copyright {
        font-size:0.8rem;
    }
</style>
</head>

  <body class="theme-base-0c ">
  <aside class="sidebar">
    <div class="container">
        <div class="sidebar-about">
            <a href="https://fgutmann.github.io/lerne-programmieren/"><h1>Lerne Programmieren</h1></a>
            <p class="lead">
                 Einfach, ohne Vorkenntnisse, online programmieren lernen. 
            </p>
        </div>

        

        <p class="copyright">
            &copy; Florian Gutmann 2018.<br />
            Alle rechte vorbehalten.
        </p>
    </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>TicTacToe - Lerne Programmieren</h1>
  <time datetime=2018-12-28T11:33:38Z class="post-date">Fri, Dec 28, 2018</time>
  

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".language-kotlin"></script>

<p>Hallo!</p>

<p>Gratulation zur deiner Entscheidung programmieren zu lernen. Programmieren zu können gibt dir die Möglichkeit neue Dinge von Grund auf zu erschaffen und eröffnet dir eine völlig neue Welt der Möglichkeiten mit deinem Computer umzugehen.</p>

<p>Egal ob du Spiele, Apps, Webseiten oder sonstige Anwendungen entwickeln willst, die Grundlagen dazu sind immer die gleichen. Es gibt zwar eine Vielzahl an verschiedenen Programmiersprachen doch im Grunde stecken nur einige wenige Konzepte dahinter die sich in all diesen Programmiersprachen wiederfinden. Wir konzentrieren uns in diesem Kurs darauf diese Konzepte auf einfache, anschauliche und interaktive Art und Weise zu vermitteln.</p>

<p>Natürlich wollen wir das ganze praktisch greifbar machen und auch Ergebnisse sehen. Als erstes werden wir daher den Spiele-Klassiker TicTacToe entwickeln. Wir werden anhand dieses Beispiels die ersten Grundlagen des Programmierens erlernen und ein komplett funktionstüchtiges Spiel entwickeln.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
import org.w3c.dom.events.Event
import org.w3c.dom.events.MouseEvent
import kotlin.math.PI

val PLAYING = 0
val WON = 1
val TIE = 2

var field = Array(9) { "_" }
var gameStatus = PLAYING
var currentPlayer = "x"
var move = 0

fun drawField() {
    context2d.save()
    context2d.beginPath()

    context2d.moveTo(0.0, 100.0)
    context2d.lineTo(300.0, 100.0)

    context2d.moveTo(0.0, 200.0)
    context2d.lineTo(300.0, 200.0)

    context2d.moveTo(100.0, 0.0)
    context2d.lineTo(100.0, 300.0)

    context2d.moveTo(200.0, 0.0)
    context2d.lineTo(200.0, 300.0)

    context2d.stroke()
    context2d.restore()
}

fun drawStone(fieldNum : Int, symbol : String) {
    val row = fieldNum / 3
    val column = fieldNum % 3

    val x = column * 100.0 + 50.0
    val y = row * 100.0 + 50.0

    context2d.beginPath()

    if (symbol == "o") {
        context2d.arc(x, y, 10.0, 0.0, 2 * kotlin.math.PI)
    } else {
        context2d.moveTo(x - 10, y - 10)
        context2d.lineTo(x + 10, y + 10)
        context2d.moveTo(x - 10, y + 10)
        context2d.lineTo(x + 10, y - 10)
    }

    context2d.stroke()
}

fun updateStatus() {
    val statusText = when (gameStatus) {
        PLAYING -> "Spieler $currentPlayer ist an der Reihe"
        WON -> "Spieler $currentPlayer hat gewonnen!"
        else -> "Untentschieden"
    }
    
    val textWidth = context2d.measureText(statusText).width

    context2d.save()
    context2d.clearRect(0.0, 300.0, 300.0, 50.0)
    context2d.fillText(statusText, (300 - textWidth) / 2, 325.0)
    context2d.restore()
}

fun isSamePlayer(idx1 : Int, idx2 : Int, idx3: Int) : Boolean {
    return field[idx1] != "_" && field[idx1] == field[idx2] && field[idx2] == field[idx3]
}

fun checkWin() : Boolean {
    val winPositions = arrayOf(
            intArrayOf(0, 1, 2),
            intArrayOf(3, 4, 5),
            intArrayOf(6, 7, 8),
            intArrayOf(0, 3, 6),
            intArrayOf(1, 4, 7),
            intArrayOf(2, 5, 8),
            intArrayOf(0, 4, 8),
            intArrayOf(2, 4, 6)
    )

    for (pos in winPositions) {
        if (isSamePlayer(pos[0], pos[1], pos[2])) {
            context2d.save()
            context2d.strokeStyle = "#4F4"
            drawStone(pos[0], currentPlayer)
            drawStone(pos[1], currentPlayer)
            drawStone(pos[2], currentPlayer)
            context2d.restore()
            return true
        }
    }

    return false
}

fun setStone(num : Int) {
    if (field[num] != "_") {
        return
    }

    field[num] = currentPlayer
    drawStone(num, currentPlayer)
    move = move + 1

    val winPosition = checkWin()

    if (winPosition) {
        gameStatus = WON
    } else if (move == 9) {
        gameStatus = TIE
    } else {
        currentPlayer = if (currentPlayer == "x") "o" else "x"
    }

    updateStatus()
}

fun reset() {
    field = Array(9) { "_" }
    gameStatus = PLAYING
    currentPlayer = "x"
    move = 0
    context2d.clearRect(0.0, 0.0, 300.0, 350.0)
    drawField()
    updateStatus()
}

fun onClick(event : Event) {
    event as MouseEvent

    if (gameStatus == PLAYING) {
        val row = event.clientY / 100
        val column = event.clientX / 100

        setStone(row * 3 + column)
    } else {
        reset()
    }
}

fun startGame() {
    canvas.onclick = ::onClick
    reset()
}

fun main() {
//sampleStart
    startGame()
//sampleEnd
}

</pre>

<p>Starte das Spiel indem du im Code-Block oben auf den grünen Start-Knopf auf der rechten Seite klickst. Spiele einige male um ein Gefühl für das Spiel zu bekommen. Am Ende der Runde, kannst du es mit einem Klick irgendwo auf das Spielfeld erneut starten.</p>

<p>In Kurzer Zeit wirst du dieses TicTacToe Spiel selbst von Grund auf entwickelt haben und genau verstehen was im Hintergrund passiert! Dieses Wissen kannst du dann schon dazu verwenden andere kleine Spiele oder Anwendungen selbst zu programmieren.</p>

<h1 id="die-wahl-der-programmiersprache">Die Wahl der Programmiersprache</h1>

<p>Für den Kursinhalt haben wir uns für die Programmiersprache Kotlin entschieden. Kotlin ist eine relativ neue, moderne Programmiersprache die in verschiedensten Umgebungen eingesetzt werden kann. So lassen sich damit zum Beispiel Handy-Apps, Browser-Basierte Spiele sowie Server-Anwendungen entwickeln. Kotlin vereint zudem in sich eine große Anzahl von Programmierkonzepten die sich auch in anderen Programmiersprachen wiederfinden. Dabei erlaubt Kotlin uns ganz einfach zu beginnen und Schritt für Schritt neue Dinge zu erklären.</p>

<p><strong>Warum lernen wir nicht die Programmiersprache Javascript, Java, Python, Scala, PHP, Swift, C#, C, C++, Rust oder eine ganz andere?</strong><br />
Ganz einfach, weil es wie du siehst sehr viele davon gibt und wir uns für eine entscheiden müssen :-) Wie bereits erwähnt sind deine neu erworbenen Kenntnisse zum Großteil das Verständnis von zugrunde liegenden Konzepten die sich in all diesen Sprachen wiederfinden. Es kommen jedes Jahr zig neue Programmiersprachen auf den Markt, neue Programmierkonzepte hingegen sind dagegen aber eher sehr selten. Ein erfahrener Software-Entwickler kann relativ einfach von einer Programmiersprache zu einer anderen wechseln. Ich persönlich habe mit fast allen der oben erwähnten Sprachen bereits gearbeitet. Der Einstieg in eine weitere Sprache dauert nur noch wenige Tage für mich.</p>

<p><strong>Warum gibt es dann diese ganzen verschiedenen Programmiersprachen überhaupt?</strong><br />
Verschiedene Sprachen haben verschiedene Hintergründe und sind oft für einen bestimmten Zweck optimiert. So eignen sich unterschiedliche Sprachen unterschiedlich gut für bestimmte Aufgaben. Zum Beispiel wurde PHP für das Erstellen von dynamischen Webseiten entwickelt und erfreut sich in diesem Bereich großer Beliebtheit. Dafür würde wohl kaum jemand auf die Idee kommen PHP für die Motor-Steuerung in einem Auto zu verwenden. In diesem Bereich sind C, C++ oder Rust aufgrund ihrer spezifischen-Eigenschaften besser geeignet.</p>

<p>Nach erfolgreichem Abschluss des Kurses hast du mit Kotlin eine sehr mächtige, breit einsetzbare Programmiersprache erlernt und dir wird es bei Bedarf auch einfach fallen dich in einer anderen Programmiersprache zurecht zu finden.</p>

<h1 id="was-ist-programmieren-überhaupt-wie-funktioniert-es">Was ist Programmieren überhaupt? Wie funktioniert es?</h1>

<p>Wenn du das fertige TicTacToe Spiel oben spielst, hast du ein fertiges Programm vor dir und weißt genau wie es funktionieren soll. Die Kunst des Programmierens ist es diese Vorstellung des fertigen Programms, welches anfangs nur in deinem Kopf existiert, so zu formulieren dass es ein Computer versteht.</p>

<p>Egal was du programmieren möchtest, du musst zuerst eine Idee in deinem Kopf haben wie das Ergebnis aussehen soll. Du kannst dir die Dinge auch aufzeichnen wie sie am Bildschirm aussehen sollen und dir überlegen wie der Benutzer mit dem Programm interagiert. Erst wenn das Bild in deinem Kopf für dich klar genug ist, kannst du beginnen deine Vision in für Computer verständliche Sprache zu übersetzen.</p>

<p>Nehmen wir als Beispiel eine Stoppuhr. Wir möchten eine Stoppuhr programmieren die die vergangene Zeit misst. Diese Beschreibung alleine ist noch viel zu ungenau um sie in ein fertiges Programm zu gießen. Wahrscheinlich ist deine Vorstellung der Stoppuhr eine ganz andere als meine.</p>

<p>Sie könnte zum Beispiel so aussehen:</p>

<figure>
    <img src="images/stopwatch-digital.png"
         alt="digitale stoppuhr" width="300"/> <figcaption>
            <h4>digitale Stoppuhr</h4>
        </figcaption>
</figure>


<p>Oder auch so:</p>

<figure>
    <img src="images/stopwatch-analog.png"
         alt="analoge stoppuhr" width="200"/> <figcaption>
            <h4>analoge Stoppuhr (Quelle: pixbay.com Lizenz: CC0 Creative Commons)</h4>
        </figcaption>
</figure>


<p>Welchen Zeitraum wollen wir überhaupt messen? Hundertstel-Sekunden? Sekunden? Minuten? Stunden? Tage? vielleicht sogar Jahre? oder Jahrzehnte? Je nachdem wird die Uhr wohl ganz anders aussehen müssen. Die analoge Version oben mit dem Zifferblatt ist für einen Zeitraum der sich über mehrere Stunden oder länger erstreckt praktisch ungeeignet, für Sekunden und Minuten bis zu einer Stunde aber sehr gut.</p>

<p>Was muss der Benutzer tun um die Uhr zu starten und zu stoppen? Auf die Uhr klicken? Zum stoppen nochmals klicken? Die Leertaste drücken? Gibt es einen eigenen Knopf dafür? All diese Dinge sollten wir uns überlegen bevor wir mit dem Schreiben von Programmcode starten. Je klarer uns ist wie die Uhr funktionieren soll, desto einfacher wird es sein sie zu programmieren.</p>

<p>Nehmen wir als Beispiel von hier an die Analoge Uhr von oben. Mit einem Klick irgendwo auf die Uhr soll sie gestartet werden und einem weiteren wieder gestoppt.</p>

<p>Nachdem wir eine genau Vorstellung haben wie unser fertiges Programm aussieht und der Benutzer mit ihm interagieren kann, wird das Programm in seine Einzelteile zerlegt die dann in Code verfasst werden. Wie genau die Einzelteile aussehen und miteinander interagieren ist flexibel und es ist die Aufgabe des Software-Entwicklers das zu entscheiden. Das ganze ist ein kreativer Prozess der etwas Übung bedarf.</p>

<p>Wir können die oben genannte Stoppuhr zum Beispiel so aufteilen:</p>

<ul>
<li>Zeichne die Uhr (ohne Zeiger) als Hintergrundbild. Dazu müssen wir ein Bild der Uhr haben auf dem keine Zeiger sichtbar sind.</li>
<li>Zeichne die beiden Zeiger in neutraler Position (beide zeigen gerade nach oben).</li>
<li>Nachdem der Benutzer auf die Uhr geklickt hat führe jede Sekunde folgende Schritte aus:

<ul>
<li>Bewege den Sekundenzeiger ein Stück weiter im Uhrzeigersinn.</li>
<li>Wenn eine Minute vergangen ist, bewege den Minutenzeiger ein Stück weiter im Uhrzeigersinn.</li>
</ul></li>
<li>Wenn der Benutzer auf die Uhr klickt und diese aktuell läuft, stoppe sie.</li>
</ul>

<p>Diese einzelnen Schritte können nun in Programmcode übersetzt werden. Dies ist einer der Hauptaufgaben beim Meistern des Programmierens. Dazu möchten wir an dieser Stelle aber nicht lange theoretisch reden sondern in den nächsten Abschnitten direkt in die Praxis übergehen und unser TicTacToeSpiel programmieren.</p>

<h1 id="tictactoe">TicTacToe</h1>

<p>Wenn du das Spiel von oben einige male gespielt hast, hast du bereits eine sehr gute Vorstellung wie das fertige Programm aussieht und wie der Benutzer damit interagieren kann. Falls du es noch nicht gespielt hast, solltest du das jetzt nachholen. Nur wenn du gut weißt, was du eigentlich programmieren möchtest kannst du zu deinem Ziel kommen.</p>

<p>Im nächsten Schritt überlegen wie wir, ähnlich wie bei der Stoppuhr, wie wir das Problem in Einzelteile zerlegen können. Wir werden dabei diesem groben Plan folgen:</p>

<ul>
<li>Zuerst zeichnen wir das Spielfeld</li>
<li>Wenn der Benutzer auf ein Kästchen im Spielfeld klickt, zeichnen wir dort das Symbol des aktuellen Spielers (X oder O)</li>
<li>Wenn 3 Felder in einer Linie (horizontal, vertikal oder diagonal) gleich sind, ist das Spiel vorbei</li>
<li>Wenn alle 9 Felder voll sind, ist das Spiel auch vorbei (unentschieden)</li>
<li>Wenn der Benutzer auf das Spielfeld klickt, und das Spiel gerade vorbei ist, starten wir das Spiel erneut:

<ul>
<li>Wir löschen den Inhalt des gesamten Spielfelds</li>
<li>Wir zeichnen das Spielfeld (wie im 1. Schritt)</li>
</ul></li>
</ul>

<p>Wir haben bewusst noch einige Teile ausgelassen, die wir erst später hinzufügen werden. Zum Beispiel haben wir uns noch keine Gedanken über den Statustext am unteren Ende des Spielfelds Gedanken gemacht. Auch die grüne Markierung wenn ein Spieler gewonnen hat, haben wir noch nicht beachtet.</p>

<h2 id="das-spielfeld-canvas-und-seine-linien">Das Spielfeld - Canvas und seine Linien</h2>

<p>Unser Spiel wird ein Browser basiertes Spiel. Als <code>Browser</code> oder auch <code>Web-Browser</code> bezeichnet man das Programm mit dem man im Internet surft. Es gibt viele verschiedene Browser wie zum Beispiel Mozilla Firefox, Internet Explorer, Google Chrome, Safari oder Opera.</p>

<p>Auch wenn diese Browser-Programme alle unterschiedlich heißen und von unterschiedlichen Herstellern sind, bieten sie für Programmierer eine einheitliche Schnittstelle wie Code ausgeführt werden kann. Das bedeutet dass du dein fertiges Spiel in jede beliebige Webseite einbinden kannst. Ohne dass der Benutzer eine extra App oder ein Programm herunterladen muss, kann er direkt in seinem Browser dein Spiel spielen. Egal ob er am Android-Handy, Laptop, Mac, oder Windows PC unterwegs ist, Firefox, Safari, Chrome oder einen anderen Browser verwendet, dein Spiel sieht immer gleich aus und funktioniert auch immer gleich.</p>

<p>Eine Schnittstelle die der Browser bietet und somit auch in der Programmiersprache Kotlin zur Verfügung steht ist das sogenannte <code>canvas</code>. Das Wort &ldquo;canvas&rdquo; ist englisch und bedeutet direkt übersetzt &ldquo;Leinwand&rdquo;.</p>

<blockquote>
<p>In der Welt der Programmierung ist nahezu alles auf Englisch gehalten, daher wirst du zu einem gewissen Grad nicht ganz um Englisch herum kommen. Viele Fachbegriffe haben überhaupt keine oder keine gute Übersetzung ins Deutsche. Je besser du dich mit Englisch anfreunden kannst, desto leichter wird dir vieles beim Programmieren fallen.</p>
</blockquote>

<p>Was können wir also mit unserem canvas machen? Na logisch, wir können darauf zeichen und das entweder in 2D oder 3D! Für unser TicTacToe Spiel reicht 2D völlig aus. Stell dir ein Blatt Papier vor auf dem wir einen Stift bewegen. Wir können ihn in gerader Linie bewegen, ihn aufheben und an eine andere Stelle setzten, wir können Kreise und Kurven zeichnen.</p>

<p>TODO: Video mit erklärung des Canvas
- Blatt papier, Kariert, moveTo, lineTo, arc</p>

<p>Unser canvas hat eine Breite von <code>300</code> und eine Höhe von <code>350</code>. Mittels <code>context2d</code> können wir in 2D auf unserem canvas zeichnen. Hier der Programmcode um eine Line von links oben nach rechts unten zu zeichnen.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    folded-button="false"
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
fun main() {
//sampleStart
    context2d.beginPath()
    context2d.moveTo(0.0, 0.0)
    context2d.lineTo(300.0, 350.0)
    context2d.stroke()
//sampleEnd
}

</pre>

<p>In der ersten Zeile sagen wir unserer 2D Zeichenumgebung, dass wir einen neuen Pfad beginnen. Wir nehmen also praktisch unsere Füllfeder in die Hand.</p>

<p>In der 2. Zeile bewegen wir die Füllfeder an die Position an der wir zu Zeichnen beginnen wollen. Die erste Zahl <code>0.0</code> gibt dabei die <code>x</code>-Koordinate, also die Position von links nach rechts an. Ganz links ist dabei die Position <code>0.0</code>. Da unser canvas wie oben beschrieben <code>300</code> breit ist, ist <code>300.0</code> ganz rechts und <code>150.0</code> in der Mitte. Die zweite Zahl gibt die <code>y</code>-Koordinate, also die Position von oben nach unten an. <code>0.0</code> ist dabei ganz oben und <code>350.0</code> wäre ganz unten, weil unser canvas eine Höhe von <code>350</code> hat. Wir haben also unsere Füllfeder ganz links oben positioniert.</p>

<p>In der 3. Zeile zeichnen wir eine gerade Line zum Punkt x <code>300.0</code> (also ganz rechts) und y <code>350.0</code> (also ganz unten).</p>

<p>In der 4. Zeile sagen wir schließlich unserer Zeichenumgebung, dass wir gerne den Pfad den wir vorhin mit der Füllfeder abgefahren sind mit einem <code>stroke</code> (deutsch Pinselstrich) zeichnen wollen. Ohne dieser letzten Anweisung bleibt unser Pfad unsichtbar.</p>

<p>Es ist bei all diesen Anweisungen dabei wichtig, dass wir die Zahlen die Koordinaten (x und y) darstellen mit mindestens einer Nachkommastelle angeben zB. <code>0.0</code> anstatt einfach nur <code>0</code>. Warum genau lernen wir etwas später wenn wir über Datentypen reden.</p>

<blockquote>
<p>Viele Code-Blöcke in diesem Kurs sind bearbeitbar und können ausgeführt werden. Du bist herzlich eingeladen mit jedem einzelnen dieser Blöcke zu spielen. Je mehr du mit dem Code experimentierst und verschiedene Dinge ausprobierst, desto schneller wirst du verstehen was passiert. Keine Angst, du kannst nichts kaputt machen :-) Wenn du diese Seite neu lädst werden alle Code-Felder zurückgesetzt.</p>
</blockquote>

<p>Schaffst du es den Code von oben so zu bearbeiten, dass wir eine zusätzliche Line von links unten nach rechts oben erhalten?
Los gehts, versuche dich darin! Probier es aus :-)</p>

<p>…</p>

<p>Bist du zu einer Lösung gekommen?</p>

<p>Hier ein Tipp: Du kannst einfach nachdem die Linie nach rechts unten gezeichnet wurde die Füllfeder mittels <code>moveTo</code> nach links unten bewegen und eine Linie mittels <code>lineTo</code> nach rechts oben zeichnen.</p>

<p>Falls es noch nicht geklappt hat, versuch es nochmals selbst bevor du dir die Lösung unten ansiehst.</p>

<p>…</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    folded-button="false"
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
fun main() {
//sampleStart
    context2d.beginPath()
    context2d.moveTo(0.0, 0.0)
    context2d.lineTo(300.0, 350.0)
    context2d.moveTo(0.0, 350.0)
    context2d.lineTo(300.0, 0.0)
    context2d.stroke()
//sampleEnd
}

</pre>

<p>Mit deinem neuen Wissen hast du alles was du benötigst um das Tic-Tac-Toe Spielfeld zu zeichnen. Es sind einfach zwei horizontale und 2 vertikale Linien. Wir zeichnen unser Spielfeld auf einer Größe von <code>300 x 300</code>. Somit müssen wir im Abstand von <code>100</code> jeweils unsere Linien zeichnen. Die unteren <code>50</code> Einheiten halten wir uns für den Statustext der anzeigt welcher Spieler gerade an der Reihe ist frei.</p>

<p>Los geht&rsquo;s!</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    folded-button="false"
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
fun main() {
//sampleStart
    context2d.beginPath()
    
    [mark]// von dir auszufüllen[/mark]
    
    context2d.stroke()
//sampleEnd
}

</pre>

<p>Geschafft?</p>

<p>Ich zeige dir hier meine Lösung. Es gibt aber auch viele andere richtige Varianten. Zum Beispiel spielt es keine Rolle in welcher Reihenfolge oder Richtung wir die einzelnen Linien Zeichnen.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    folded-button="false"
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
fun main() {
//sampleStart
    context2d.beginPath()
    
    // 1. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 100.0)
    context2d.lineTo(300.0, 100.0)
    
    // 2. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 200.0)
    context2d.lineTo(300.0, 200.0)
    
    // 1. vertikale Linie von oben nach unten
    context2d.moveTo(100.0, 0.0)
    context2d.lineTo(100.0, 300.0)
    
    // 2. vertikale Linie von oben nach unten
    context2d.moveTo(200.0, 0.0)
    context2d.lineTo(200.0, 300.0)
    
    context2d.stroke()
//sampleEnd
}

</pre>

<p>In dieser Lösung sind noch zwei neue Dinge, die wir bisher noch nicht gesehen haben.</p>

<p>Wir haben manchmal Zeilen für bessere Lesbarkeit frei gelassen. Kotlin ignoriert alle Zeilen auf denen kein Text steht. Du kannst Zeilen freilassen um zusammengehörigen Code zu gruppieren. Wie genau du deinen Code gruppierst ist zum Großteil Geschmacksache und dir überlassen.</p>

<p>Wir haben Kommentare eingefügt die beschreiben was geschieht. Alle Zeilen die mit zwei Schrägstrichen <code>//</code> beginnen werden von Kotlin ignoriert. Diese sind nur für Menschen gedacht. Du kannst dir selbst so viele Kommentare setzten wie du möchtest. Kommentare sind ein wichtiges Werkzeug um den Code zu dokumentieren. So kennst du dich selbst gleich wieder aus, auch wenn du nach einigen Monaten erst wieder zu dem Code zurückkehrst und auch andere Entwickler können mit guten Kommentaren deinen Code viel schneller verstehen.</p>

<p><strong>Gratulation!</strong> Du hast den ersten Schritt unseres Spiels erfolgreich programmiert! Das Spielfeld ist erfolgreich dargestellt.</p>

<h2 id="funktionen">Funktionen</h2>

<p>TODO: Warum sind funktionen cool? Beschreiben</p>

<p>Bevor wir damit beginnen die Spielsteine in der Form von X und O auf unserem Feld zu platzieren, widmen wir uns noch kurz dem Thema Funktionen. Eine Funktion in der Programmierung ist ein Stück zusammengehöriger Programmcode der auf einmal ausgeführt wird. Diese Codeblöcke können dann von anderen Stellen im Code aufgerufen werden. Wir verwenden Funktionen zum Strukturieren unseres Programms.</p>

<p>Funktionen können keine, einen oder mehrere Werte als Eingabe haben. Das sind die sogenannten Parameter. Mit diesen Parametern kann die Funktion Informationen erhalten die sie benötigt um ihre Arbeit zu verrichten.</p>

<p>Zusätzlich kann eine Funktion auch einen Wert an den Code der die Funktion aufruft zurückliefern. Das ist der sogenannte return Wert. Nicht alle Funktionen geben einen Wert zurück.</p>

<h3 id="funktionsaufrufe">Funktionsaufrufe</h3>

<p>Du hast beim Zeichnen der Linien bereits mehrere Funktionen kennen gelernt und aufgerufen. Der Code <code>context2d.beginPath()</code> ruft die Funktion <code>beginPath</code> des Objekts <code>context2d</code> auf. Der Code <code>context2d.moveTo(0.0, 200.0)</code> ruft die Funktion <code>moveTo</code> des Objekts <code>context2d</code> auf und übergibt 2 Parameter, die Zahlen <code>0.0</code> und <code>200.0</code> an die Funktion.</p>

<p>In Kotlin, sowie auch vielen anderen Programmiersprachen, wird ein Funktionsaufruf im allgemeinen so geschrieben.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    
    data-highlight-only
    folded-button="false"
>
    
objekt.nameDerFunktion(parameter1, parameter2)
  1   2      3        4     5    5     5     6

</pre>

<ol>
<li>Zuerst kommt der Name des Objekts zu dem die Funktion gehört. Dieser Teil ist nicht immer vorhanden, weil nicht jede Funktion zu einem Objekt gehört.</li>
<li>Durch einen Punkt wird dar Name des Objekts vom Namen der Funktion getrennt. Gehört die Funktion nicht zu einem Objekt, entfällt auch dieser Teil.</li>
<li>Danach kommt der Name der Funktion.</li>
<li>Eine runde Klammer auf <code>(</code> beendet den Funktionsnamen und beginnt die Liste der Parameter.</li>
<li>Es folgen die Parameter die an die Funktion übergeben werden. Mehrere Parameter sind durch ein Komma getrennt. Es kann auch sein, dass keine Parameter vorhanden sind.</li>
<li>Eine runde Klammer zu <code>)</code> beendet den Funktionsaufruf.</li>
</ol>

<p>Hier zwei Beispiele die wir schon oben gesehen haben:</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    
    data-highlight-only
    folded-button="false"
>
    
context2d.stroke()

</pre>

<p>Dieser Code ruft die Funktion mit dem Namen <code>stroke</code> des Objekts <code>context2d</code> auf. Die Funktion <code>stroke</code> hat keine Parameter, daher kommt die Klammer zu <code>)</code> direkt nach der öffnenden Klammer.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    
    data-highlight-only
    folded-button="false"
>
    
context2d.lineTo(300.0, 100.0)

</pre>

<p>Dieser Code ruft die Funktion mit dem Namen <code>lineTo</code> des Objekts <code>context2d</code> auf. Diese Funktion hat 2 Parameter die sie benötigt um zu wissen wo das Ende der Linie sein soll. Der erste Parameter ist der Wert <code>300.0</code>. Der zweite Parameter folgt mit einem Komma getrennt und hat den Wert <code>100.0</code>. Auf diese Weise haben wir der Funktion <code>lineTo</code> mitgeteilt auf welchen Koordinaten das Ende der Linie sein soll.</p>

<p>Und hier noch ein neues Beispiel einer Funktion die wir bisher noch nicht kennen gelernt haben. Dieser Code ist übrigens wieder ausführbar.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="0"
    
    folded-button="false"
>
    
fun main() {
//sampleStart
println("Hello World!")
//sampleEnd
}

</pre>

<p>Hier rufen wir eine Funktion mit dem Namen <code>println</code> auf. Da diese zu keinem Objekt gehört entfällt der Name des Objekts und der zugehörige Punkt. Der Funktion wird ein Parameter übergeben und zwar der Text <code>Hello World!</code>. Texte werden in Kotlin unter doppelte Anführungszeichen gesetzt.</p>

<p><code>println</code> ist eine Abkürzung die für &ldquo;print line&rdquo; steht was wörtlich auf Deutsch mit &ldquo;drucke zeile&rdquo; übersetzt werden kann. Praktisch bedeutet es aber &ldquo;gib eine Zeile Text aus&rdquo; und hat mit echten Druckern nichts zu tun. Wo genau die Zeile ausgegeben wird hängt von der Umgebung in der das Programm ausgeführt wird aus. In unserem Fall wird es unter dem Eingabefeld am Bildschirm angezeigt.</p>

<h3 id="funktionsdefinitionen">Funktionsdefinitionen</h3>

<p>Alle Funktionen die wir bisher aufgerufen haben, wie zum Beispiel <code>println</code> oder die Funktion <code>stroke</code> des Objekts <code>context2d</code>, sind in der Programmiersprache Kotlin bereits vorhanden. Wir können aber auch unsere eigenen Funktionen erstellen und so unseren Code strukturieren.</p>

<p>Zum Beispiel ist es sinnvoll den Code der unser Spielfeld zeichnet in eine eigene Funktion namens <code>drawField</code> zu verpacken. Das ermöglicht uns, dass wir von überall in unserem Code diese Funktion mit dem einfachen Stück Code <code>drawField()</code> aufrufen können und das Spielfeld wird gezeichnet. Dabei müssen wir beim Schreiben des Funktionsaufrufs nicht mehr über all die Details wie <code>beginPath</code>, <code>moveTo</code> und <code>lineTo</code> nachdenken. All diese Details sind in unserer Funktion <code>drawField</code> versteckt.</p>

<p>Die Definition einer Funktion ohne Parameter und ohne Rückgabewert (Englisch &ldquo;return value&rdquo;) sieht in Kotlin so aus:</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    
    data-highlight-only
    folded-button="false"
>
    
fun nameDerFunktion() {
    // code der Funktion
}

</pre>

<p>Das Wort <code>fun</code> ist eine Abkürzung für das Wort &ldquo;function&rdquo; was übersetzt &ldquo;Funktion&rdquo; bedeutet. Danach kommt der Name der Funktion, gefolgt von Klammer auf und gleich wieder zu <code>()</code>. Hätte unsere Funktion Parameter würden wir diese zwischen den Klammern definieren.</p>

<p>Als nächstes folgt eine geschwungene Klammer auf <code>{</code> die den Beginn des Codes der Funktion markiert. Am Ende haben wir eine geschwungene Klammer zu <code>}</code> die das Ende des Codes der Funktion markiert. Zwischen den geschwungenen Klammern steht also der Code unserer Funktion. Im Englischen heißt dieser Teil der Funktion &ldquo;function body&rdquo; oder auch einfach nur &ldquo;body&rdquo;. Auf Deutsch könnte man es wohl mit &ldquo;Funktionskörper&rdquo; übersetzen.</p>

<blockquote>
<p>Wir werden Fachbegriffe wie &ldquo;function body&rdquo;, &ldquo;parameter&rdquo;, &ldquo;return value&rdquo; und dergleichen immer mehr auf Englisch verwenden, da diese in der Praxis so viel geläufiger sind. Diese Wörter kommen oft auch in der Programmiersprache selbst vor und sind dort immer in Englisch. Daher gibt es praktisch keinen Weg daran vorbei diese Wörter auf Englisch zu verstehen. Meist ist es nicht mal notwendig das Wort überhaupt auf Deutsch zu kennen da es sich hier um Fachbegriffe handelt die einfach immer auf Englisch verwendet werden. Das Wort &ldquo;Funktionskörper&rdquo; zum Beispiel habe ich bisher in der Praxis in über 15 Jahren noch nie gehört :-) Es ist einfach der &ldquo;function body&rdquo; oder &ldquo;body of the function&rdquo;.</p>
</blockquote>

<p>Unsere Funktion für das Zeichnen des Felds sieht fertig so aus:</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    folded-button="false"
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
fun drawField() {
    context2d.beginPath()
    
    // 1. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 100.0)
    context2d.lineTo(300.0, 100.0)
    
    // 2. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 200.0)
    context2d.lineTo(300.0, 200.0)
    
    // 1. vertikale Linie von oben nach unten
    context2d.moveTo(100.0, 0.0)
    context2d.lineTo(100.0, 300.0)
    
    // 2. vertikale Linie von oben nach unten
    context2d.moveTo(200.0, 0.0)
    context2d.lineTo(200.0, 300.0)
    
    context2d.stroke()
}

</pre>

<p>Wir haben einfach den Code der das Spielfeld zeichnet von weiter oben als unseren function body verwendet und der Funktion den Namen <code>drawField</code> gegeben. Da unsere Funktion keine Parameter hat, steht in den Klammern hinter dem Namen der Funktion nichts.</p>

<p>Den Code in der Funktion haben wir mit jeweils 4 Leerzeichen vom linken Rand eingerückt. Diese Einrückung lässt uns sofort erkennen wo die Funktion startet und wo sie endet. Für Kotlin macht es keinen Unterschied ob wir diese Einrückung machen oder nicht, für uns Menschen aber schon.</p>

<p>Wenn du den Code von oben ausführst passiert nichts, weil wir nur die Funktion definiert, aber nie aufgerufen haben.</p>

<blockquote>
<p>Um die Einrückung von oben vorzunehmen musst du nicht vor jeder einzelnen Zeile manuell 4 Leerzeichen tippen. Du kannst einfach alle Zeilen die du einrücken möchtest mit der Maus markieren und danach die Tabulator Taste, die auch oft nur Tab-Taste genannt wird, drücken. Diese findest du auf deiner Tastatur zwei Tasten über der Großschreibtaste. Das Symbol darauf ist auf den meisten Tastaturen ein oder zwei Pfeile die nach rechts bzw links zeigen. Zum Einrücken einer einzelnen Zeile kannst du einfach den Cursor auf den Anfang der Zeile setzen und einmal die Tab-Taste drücken. Um Code wieder nach links zu rücken einfach die Großschreibtaste halten und zugleich die Tab-Taste drücken.</p>

<p>Die Symbole für die geschwungenen Klammern <code>{}</code> sind nicht immer auf die Tastatur gedruckt und daher manchmal schwer zu finden. Diese sind zudem auf Mac-Tastaturen wo anders zu finden als auf PC-Tastaturen. PC Benutzer können diese über die Tastenkombination <code>Alt Gr + 7</code> und <code>Alt Gr + 0</code> tippen. Mac Benutzer erreichen diese über die Kombination <code>Cmd + 8</code> und <code>Cmd + 9</code>.</p>
</blockquote>

<h3 id="die-main-funktion">Die Main Funktion</h3>

<p>Bisher hast du, wenn du Code ausführen wolltest, diesen einfach hingeschrieben und auf den Start-Knopf gedrückt. Wir haben dir dabei aber ein Detail verschwiegen. Wir haben etwas Code der für das Ausführen des Programms notwendig ist vor dir versteckt.</p>

<p>Hier nochmals das &ldquo;Hello World!&rdquo; Beispiel von oben. Diesmal gibt es aber mit dem <code>+</code>, einen Knopf der dir den versteckten Code anzeigt.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="0"
    
    
>
    
fun main() {
//sampleStart
    println("Hello World!")
//sampleEnd
}

</pre>

<p>Wenn du den versteckten Code sichtbar schaltest, siehst du dass wir eine Funktionsdefinition mit dem Namen <code>main</code> vor dir versteckt haben. Jeder Code den du bisher geschrieben hast, war eigentlich immer der function body der Funktion mit dem Namen <code>main</code>!</p>

<p>In jedem Kotlin Programm wird beim Start des Programms damit begonnen den Code in der Funktion mit dem Namen <code>main</code> auszuführen. Diese Konvention ist in sehr vielen Programmiersprachen so. Die Funktion <code>main</code> wird aufgerufen wenn dein Programm startet. Schließlich muss der Computer ja irgendwo damit beginnen den Code auszuführen und woher sollte er wissen wo er beginnen muss wenn dein Programm 100 verschiedene Funktionen enthält?</p>

<p>Unser Programm mit der <code>drawField</code> Funktion von oben hat nichts gemacht als wir es ausgeführt haben. Das liegt daran, dass es im Code keine <code>main</code> Funktion gibt bei der der Computer anfangen kann unseren Code auszuführen. Um unser Spielfeld zu sehen müssen wir also eine <code>main</code> Funktion hinzufügen die unsere <code>drawField</code> Funktion aufruft.</p>

<p>Mit deinem neuen Wissen über Funktionen und den Beispielen von oben hast du alles Notwendige um die <code>main</code> Funktion im Code hinzuzufügen die unsere <code>drawField</code> Funktion aufruft. Wenn du alles richtig gemacht hast und den Code ausführst ist das Spielfeld wieder zu sehen.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    folded-button="false"
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
fun drawField() {
    context2d.beginPath()
    
    // 1. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 100.0)
    context2d.lineTo(300.0, 100.0)
    
    // 2. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 200.0)
    context2d.lineTo(300.0, 200.0)
    
    // 1. vertikale Linie von oben nach unten
    context2d.moveTo(100.0, 0.0)
    context2d.lineTo(100.0, 300.0)
    
    // 2. vertikale Linie von oben nach unten
    context2d.moveTo(200.0, 0.0)
    context2d.lineTo(200.0, 300.0)
    
    context2d.stroke()
}

[mark]// Füge hier die main Funktion ein, die unsere drawField Funktion aufruft.[/mark]

</pre>

<h2 id="setzen-der-spielsteine">Setzen der Spielsteine</h2>

<p>Nachdem wir so viel über Funktionen gelernt haben wird es Zeit wieder zu unserem TicTacToe Spiel zurück zu kehren. Den ersten Punkt unseres groben Plans, das Spielfeld zu zeichnen, haben wir schon erledigt. Als nächsten Schritt wollen wir bei einem Klick auf das Spielfeld an diese Stelle den Stein des aktuellen Spielers setzen (X oder O).</p>

<p>Um den Code übersichtlich zu halten werden wir zuerst eine Funktion schreiben die einen Spielstein auf das Feld zeichnet. Als Name für die Funktion ist <code>drawStone</code>, also übersetzt &ldquo;zeichne Stein&rdquo; ganz gut geeignet. Es ist ein sehr einfacher, kurzer Name der gut beschreibt was die Funktion tut.</p>

<blockquote>
<p>Das Finden von guten Namen ist beim Programmieren eine der wichtigsten und eine der schwersten Aufgaben zugleich. Wenn dein Programm aus logischen, einfachen Wörtern besteht wirst du dich auch später wieder schnell im Code zurecht finden. Wenn du aber keine guten Namen findest und zum Beispiel als Namen für deine Funktionen <code>abrakadabra</code> und <code>hokuspokus</code> verwendest, wird dein Programm zwar auch funktionieren aber du wirst sehr schnell den Überblick verlieren und es wird dir schwer fallen komplexere Dinge zu programmieren.</p>
</blockquote>

<p>Was muss unsere Funktion <code>drawStone</code> wissen um ihre Arbeit erfolgreich zu verrichten?</p>

<ol>
<li>Sie muss wissen in welches Kästchen des Spielfelds der Spielstein gesetzt werden soll.</li>
<li>Außerdem muss die Funktion wissen welches Symbol gesetzt werden soll. Entweder ein X oder ein O.</li>
</ol>

<p>Diese Informationen werden wir der Funktion <code>drawStone</code> als zwei Parameter übergeben.</p>

<p>Parameter einer Funktion bestehen aus einem Namen und einem Datentyp (englisch &ldquo;type&rdquo;). Der Name wird verwendet um im Code auf den übergebenen Wert zuzugreifen. Der Datentyp gibt an welche Art von Wert an die Funktion übergeben wird. Das kann zum Beispiel eine Zahl oder ein Text sein. Bei Zahlen wird noch weiter unterschieden ob es sich um eine Ganzzahl oder eine Komma-Zahl handelt. Es gibt noch einige weitere Datentypen über die wir erst später sprechen werden. Hier einmal die wichtigsten die wir für unser Spiel benötigen.</p>

<table>
<thead>
<tr>
<th>Name in Kotlin</th>
<th>Beschreibung</th>
<th>Beispiele</th>
</tr>
</thead>

<tbody>
<tr>
<td>Int</td>
<td>Ganzzahl</td>
<td><code>1</code>, <code>1002</code>, <code>-494</code></td>
</tr>

<tr>
<td>Double</td>
<td>Komma-Zahl</td>
<td><code>1.3</code>, <code>10.0</code>, <code>-4596.328494</code></td>
</tr>

<tr>
<td>String</td>
<td>Text</td>
<td><code>&quot;Hallo&quot;</code>, <code>&quot;Ein langer Satz&quot;</code> <code>&quot;X&quot;</code></td>
</tr>
</tbody>
</table>

<p>Diese Datentypen heißen in sehr vielen Programmiersprachen genau so. &ldquo;Int&rdquo; wird jedoch in manchen Programmiersprachen als &ldquo;Integer&rdquo; ausgeschrieben. Wenn du einen String, also einen Text, im Code schreibst darfst du nicht darauf vergessen diesen unter doppelte Anführungszeichen zu setzten.</p>

<p>Wir werden unserer <code>drawStone</code> Funktion als ersten Parameter eine Zahl von <code>0</code> bis <code>8</code> übergeben die angibt in welches Kästchen der Spielstein gezeichnet werden soll. Da es sich dabei um ganze Zahlen handelt hat der erste Parameter den Datentyp <code>Int</code>. Dabei nummerieren wir die Spielfelder von links oben nach rechts unten durch. Hier eine Illustration wie die einzelnen Felder in unserem Spielfeld nummeriert sind.</p>

<pre><code>         |         |
    0    |    1    |    2
         |         |
-----------------------------
         |         |
    3    |    4    |    5
         |         |
-----------------------------
         |         |
    6    |    7    |    8
         |         |
</code></pre>

<p>Als zweiten Parameter übergeben wir der Funktion als String (also Text) welches Symbol gezeichnet werden soll. Wenn wir <code>&quot;x&quot;</code> übergeben, soll die Funktion ein <code>x</code> Symbol zeichnen.  Wenn wir ein <code>&quot;o&quot;</code> übergeben, soll die Funktion das <code>o</code> Symbol zeichnen.</p>

<p>Wenn wir unsere Funktion <code>drawStone</code> mit dem Codestück <code>drawStone(4, &quot;x&quot;)</code> aufrufen, soll die Funktion also in das mittlere Kästchen ein <code>x</code> zeichnen.<br />
Bei <code>drawStone(0, &quot;o&quot;)</code> ein <code>o</code> in das links obere Feld.</p>

<blockquote>
<p>In der Programmierung ist es üblich, wenn Dingen eine Nummer zugewiesen wird, dass bei <code>0</code> anstatt bei <code>1</code> begonnen wird. Die Gründe dafür liegen weit zurück in der Geschichte der Programmierung. In den meisten Programmiersprachen hat sich diese Praxis bis heute gehalten. Daher schließen wir uns dem an und versuchen uns von Anfang an daran zu gewöhnen.</p>
</blockquote>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
fun drawField() {
    context2d.beginPath()
    
    // 1. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 100.0)
    context2d.lineTo(300.0, 100.0)
    
    // 2. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 200.0)
    context2d.lineTo(300.0, 200.0)
    
    // 1. vertikale Linie von oben nach unten
    context2d.moveTo(100.0, 0.0)
    context2d.lineTo(100.0, 300.0)
    
    // 2. vertikale Linie von oben nach unten
    context2d.moveTo(200.0, 0.0)
    context2d.lineTo(200.0, 300.0)
    
    context2d.stroke()
}

//sampleStart
fun drawStone(fieldNum : Int, symbol : String) {
    // Hier kommt der Code zum Zeichnen des Symbols hin.
}

fun main() {
    drawField()
    drawStone(0, "x")
    drawStone(1, "o")
    drawStone(5, "x")
    drawStone(6, "o")
    drawStone(2, "x")
}
//sampleEnd

</pre>

<p>Im Code oben haben wir die Funktion <code>drawStone</code> definiert. Wir beginnen wie bei allen Funktionsdefinitionen mit dem Wort <code>fun</code>. Danach kommt der Name der Funktion, also <code>drawStone</code>. Dahinter geht die Klammer auf und die Liste der Parameter beginnt. Diesmal haben wir 2 Parameter. Zuerst kommt der Name des ersten Parameters. In diesem Fall <code>fieldNum</code>, eine Abkürzung für &ldquo;field number&rdquo;, zu Deutsch also &ldquo;Feldnummer&rdquo;. Hinter dem Namen kommt ein Doppelpunkt <code>:</code> und danach der Datentyp. Da wir als Feldnummer eine Zahl von 0 bis 8 übergeben ist es <code>Int</code>. Danach kommt ein Komma um zu zeigen, dass ein weiterer Parameter folgt. Dieser hat den Namen <code>symbol</code>, also Symbol. Der Datentyp folgt wieder nach dem Doppelpunkt. Da wir hier entweder <code>&quot;x&quot;</code> oder <code>&quot;o&quot;</code>, also einen Text, übergeben ist er <code>String</code>.</p>

<blockquote>
<p>Wir übergeben als Text an unsere Funktion <code>&quot;x&quot;</code> und <code>&quot;o&quot;</code>, also eigentlich nur einen einzigen Buchstaben und keinen richtigen Text. Trotzdem ist unser Datentyp <code>String</code>. Ein String kann ein beliebig langer oder kurzer Text sein. Ein Buchstabe ist dabei völlig ausreichend. Selbst Text mit keinem einzigen Buchstaben ist grundsätzlich erlaubt und wird als <code>&quot;&quot;</code> geschrieben. In der Fachsprache heißt dieser Spezielle Text, der keinen einzigen Buchstaben enthält &ldquo;empty string&rdquo;, zu deutsch also &ldquo;leerer Text&rdquo;.</p>
</blockquote>

<p>Nachdem wir unsere Funktion definiert haben und wissen wie sie aufgerufen wird sind wir soweit den Code innerhalb der Funktion, also den function body zu schreiben.</p>

<p>Zum Zeichnen des <code>x</code> Symbols können wir wieder wie beim Zeichnen des Spielfelds die <code>moveTo</code> und <code>lineTo</code> Funktionen vom <code>context2d</code> Objekt verwenden. Wir müssen nur 2 diagonale Linien zeichnen um das <code>x</code> Symbol zu erhalten.</p>

<p>Zum Zeichnen des <code>o</code> Symbols gibt es eine Funktion am <code>context2d</code> Objekt welche einen Kreisbogen zeichnet. Ein Kreisbogen ist einfach ein Ausschnitt eines Kreises. Wenn du einen Zirkel verwendest und nur einen Teil des Kreises zeichnest, hast du einen Kreisbogen gezeichnet. Wenn du den Kreisbogen komplett fertig zeichnest, hast du einen Kreis.</p>

<p>Die Funktion zum Zeichnen des Kreisbogens zeichnet einen Kreisbogen im Uhrzeigersinn und sieht so aus:</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    
    data-highlight-only
    folded-button="false"
>
    
fun arc(x : Double, y: Double, radius: Double, startAngle: Double, endAngle: Double)

</pre>

<p>Der name &ldquo;arc&rdquo; ist dabei das Englische Wort für Kreisbogen. Dies sind die Parameter der Funktion:</p>

<ul>
<li><code>x</code>: Die x-Koordinate der Kreismitte auf dem canvas.</li>
<li><code>y</code>: Die y-Koordinate der Kreismitte auf dem canvas.</li>
<li><code>radius</code>: Der Radius des Kreises (wie weit der Zirkel geöffnet werden soll).</li>
<li><code>startAngle</code>: Der Winkel in Radianten bei dem zu Zeichnen begonnen werden soll.</li>
<li><code>endAngle</code>: Der Winkel in Radianten bei dem zu Zeichnen beendet wird.</li>
</ul>

<blockquote>
<p>Radianten sind eine Darstellungsform für Winkel. 2 π in Radianten bedeutet der volle Kreis (360°). 1 π in Radianten wäre ein halber Kreis (180°). Da wir einen ganzen Kreis zeichnen wollen können wir einfach bei <code>startAngle</code> <code>0</code> beginnen und bis <code>endAngle</code> <code>2 π</code> zeichnen. Das Zeichen <code>π</code> (Pi) steht für die Mathematische Konstante für das Verhältnis von Kreisumfang zu Kreisdurchmesser. Der Wert von π ist ca. <code>3.14159</code>.</p>
</blockquote>

<p>In Kotlin können wir auf den Wert der Konstante π mittels <code>kotlin.math.PI</code> zugreifen. Um einen vollen Kreis an die Position <code>x:100, y:100</code> mit dem radius von <code>50</code> zu zeichnen rufen wir die Funktion so auf:</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    
    data-highlight-only
    folded-button="false"
>
    
context2d.arc(100.0, 100.0, 50.0, 0.0, 2 * kotlin.math.PI)

</pre>

<p>Egal ob wir das <code>x</code> Symbol oder das <code>o</code> zeichnen wollen, müssen wir zuerst wissen an welche Stelle wir zeichnen wollen. Erinnern wir uns zurück an unsere Funktionsdefinition.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    
    data-highlight-only
    folded-button="false"
>
    
fun drawStone(fieldNum : Int, symbol : String)

</pre>

<p>Wir bekommen als ersten Parameter die Feldnummer und müssen nun von dieser Nummer zu einer x / y position am Spielfeld kommen. Als erstes müssen wir wissen in welcher reihe und in welcher Spalte unser Spielstein positioniert werden soll. Rufen wir uns kurz die Feldnummerierung zurück ins Gedächtnis:</p>

<pre><code>         |         |
    0    |    1    |    2
         |         |
-----------------------------
         |         |
    3    |    4    |    5
         |         |
-----------------------------
         |         |
    6    |    7    |    8
         |         |
</code></pre>

<p>In der ersten Reihe haben wir die Nummern 0, 1 und 2. In der zweiten Reihe 3, 4, 5 und in der dritten Reihe 6, 7 und 8. Wenn wir die Feldnummer durch 3 dividieren erhalten wir die Reihe. Wenn wir den Rest dieser Division nehmen erhalten wir die Spalte:</p>

<pre><code>0 / 3 = 0 mal 0 rest
1 / 3 = 0 mal 1 rest
2 / 3 = 0 mal 2 rest
3 / 3 = 1 mal 0 rest
4 / 3 = 1 mal 1 rest
5 / 3 = 1 mal 2 rest
6 / 3 = 3 mal 0 rest
7 / 3 = 3 mal 1 rest
8 / 3 = 3 mal 2 rest
</code></pre>

<p>Um eine Zahl zu dividieren, schreiben wir einfach <code>zahl1 / zahl2</code> der Schrägstrich bedeutet dividieren. Wenn wir zwei <code>Int</code> Zahlen (Ganzzahlen) dividieren erhalten wir immer eine Ganzzahl. Der Rest wird einfach verworfen.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="0"
    
    folded-button="false"
>
    
fun main() {
    println(5 / 3)
}

</pre>

<p>Dieses kleine Programm gibt <code>1</code> aus. Weil wir 2 Ganzzahlen dividieren wird der Rest der Division einfach verworfen und als Ergebnis bleibt <code>1</code>.</p>

<p>Spiele mit einigen verschiedene Zahlen oben in dem Beispiel. Was passiert wenn du eine Komma-Zahl verwendest? Achte darauf, dass wir Komma-Zahlen mit einem Punkt und nicht mit einem Komma trennen. Also zum Beispiel <code>3.4</code> anstatt <code>3,4</code>. Diese Schreibweise kommt übrigens auch aus dem Englischen.</p>

<p>Um den Rest einer Ganzzahl-Division zu bekommen können wir den so genannten &ldquo;modulo&rdquo; operator verwenden. Dieser ist einfach ein <code>%</code> Zeichen. Spiele dich ein bisschen mit der Modulo Division im unteren Code-Beispiel.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="0"
    
    folded-button="false"
>
    
fun main() {
    println(5 % 3)
}

</pre>

<p>Um zur unserer Spalte und Reihe zu kommen können wir also folgenden Code verwenden:</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    
    data-highlight-only
    folded-button="false"
>
    
var row = fieldNum / 3
var column = fieldNum % 3

</pre>

<p>Wir dividieren in der ersten Zeile dividieren wir die Feldnummer durch 3. Da die Feldnummer in unserem Beispiel eine Ganzzahl ist und auch <code>3</code> eine Ganzzahl ist kommt immer eine Ganzzahl heraus. Der Rest der Division wird einfach verworfen. Das Ergebnis dieser Division speichern wir in der Variable mit dem Namen <code>row</code>.</p>

<p>In der zweiten Zeile berechnen wir die Spalte, indem wir die Restwertdivision mit dem modulo operator ausführen. Das Ergebnis speichern wir in der Variable <code>column</code> zwischen.</p>

<p>Nun können wir den Mittelpunkt des Kästchens berechnen. Unser Spielfeld ist 300 breit und 300 hoch. Jedes einzelne Kästchen ist also 100 breit und 100 hoch. Mit dieser Information können wir sehr einfach den Mittelpunkt berechnen. Ergänze im Code unten die Berechnung von <code>y</code>. Immer wenn in einem Code-Beispiel <code>TODO()</code> steht, ist es deine Aufgabe an dieser Stelle den Code zu ergänzen.</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="0"
    
    folded-button="false"
>
    
fun main() {
    drawStone(0, "x")
    drawStone(1, "o")
    drawStone(2, "x")
    drawStone(5, "o")
    drawStone(6, "x")
}

fun drawStone(fieldNum : Int, symbol : String) {
    var row = fieldNum / 3
    var column = fieldNum % 3

    // Berechnung der x-Koordinate des Mittelpunkts des Kästchens
    val x = column * 100.0 + 50.0
    // Berechnung der y-Koordinate des Mittelpunkts des Kästchens
    val y = [mark]TODO()[/mark]
    
    // Hier folgt später der Code zum Zeichnen des Symbols.
    // Um zu sehen ob unsere Berechnung für den Mittelpunkt stimmt,
    // geben wir aktuell einfach die berechneten Koordinaten aus.
    println("fieldNum: ${fieldNum}, x: ${x}, y: ${y}")
}

</pre>

<p>// TODO If anweisung von unten erklären</p>

<pre
    class="language-kotlin" data-target-platform="canvas"
    data-output-height="370"
    
    
>
    
<textarea class="hidden-dependency">
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.HTMLCanvasElement
import kotlin.browser.document
import kotlin.dom.createElement

fun setupCanvas(): HTMLCanvasElement {
    val canvas = document.createElement("canvas") {
        setAttribute("width", "600")
        setAttribute("height", "700")
    } as HTMLCanvasElement

    canvas.style.width = "300px"
    canvas.style.height = "350px"
    canvas.style.margin = "10px 10px 0 10px"

    document.body!!.append(canvas)

    return canvas
}

fun setupRenderingContext(canvas : HTMLCanvasElement) : CanvasRenderingContext2D {
    val context = canvas.getContext("2d") as CanvasRenderingContext2D
    context.font = "14px Arial"
    context.translate(0.5,0.5)
    context.setTransform(2.0, 0.0, 0.0, 2.0, 0.0, 0.0)

    return context
}

val canvas = setupCanvas()
val context2d = setupRenderingContext(canvas)
</textarea>
fun drawField() {
    context2d.beginPath()
    
    // 1. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 100.0)
    context2d.lineTo(300.0, 100.0)
    
    // 2. horizontale Linie von links nach rechts
    context2d.moveTo(0.0, 200.0)
    context2d.lineTo(300.0, 200.0)
    
    // 1. vertikale Linie von oben nach unten
    context2d.moveTo(100.0, 0.0)
    context2d.lineTo(100.0, 300.0)
    
    // 2. vertikale Linie von oben nach unten
    context2d.moveTo(200.0, 0.0)
    context2d.lineTo(200.0, 300.0)
    
    context2d.stroke()
}

//sampleStart
fun drawStone(fieldNum : Int, symbol : String) {
    var row = fieldNum / 3
    var column = fieldNum % 3
    
    var x = column * 100.0 + 50.0
    var y = row * 100.0 + 50.0

    context2d.beginPath()
    
    if (symbol == "o") {
        context2d.arc(x, y, 10.0, 0.0, 2 * kotlin.math.PI)
    } else {
        // Füge hier deinen Code zum Zeichnen des x - Symbols ein
        TODO()
    }
    
    context2d.stroke()
}
//sampleEnd

fun main() {
    drawField()
    drawStone(0, "x")
    drawStone(1, "o")
    drawStone(2, "x")
    drawStone(5, "o")
    drawStone(6, "x")
}

</pre>

</div>


    </main>

    
  </body>
</html>
